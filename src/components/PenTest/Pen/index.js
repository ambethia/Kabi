'use strict'

import last from 'lodash/last'
import merge from 'lodash/merge'
import forEach from 'lodash/forEach'
import cloneDeep from 'lodash/cloneDeep'
import first from 'lodash/first'
import tail from 'lodash/tail'
import initial from 'lodash/initial'
import Point from './Point'
import BezierDrawer from './BezierDrawer'

const defaultPenColor = { r: 0, g: 0, b: 0 }
const defaultFilterWeight = 0.5
const defaultStepInterval = 0.3
const defaultSample = 2

// DOM
var w
var h
var ctx
var canvas

// State
var rawStrokes
var curRawSampledStroke
var curFilteredStroke
var pointCounter
var sample
var filterWeight
var bezierDrawer

// ------------------------------------------
// Pen
//
// Constructor for Pen instances. Accepts
// an HTML <canvas> Element element to render
// strokes onto.
//
export default class Pen {

  constructor (passedCanvas, optConfig) {
    canvas = passedCanvas
    w = canvas.getAttribute('width')
    h = canvas.getAttribute('height')
    ctx = canvas.getContext('2d')
    ctx.imageSmoothingEnabled = false
    var config = this.getConfiguration(optConfig || {})
    sample = config.sample
    filterWeight = config.filterWeight
    bezierDrawer = new BezierDrawer(canvas, config.inkTextureBase, config.penColor, config.stepInterval)
    this.clear()
  }

  getConfiguration (config) {
    let defaultConfig = {
      sample: defaultSample,
      penColor: defaultPenColor,
      filterWeight: defaultFilterWeight,
      stepInterval: defaultStepInterval
    }
    return merge(defaultConfig, config)
  }

  // ------------------------------------------
  // clear
  //
  // Clears the canvas.
  //
  clear () {
    // Clear canvas
    ctx.clearRect(0, 0, w, h)
    ctx.fillStyle = 'white'
    ctx.globalAlpha = 1
    ctx.fillRect(0, 0, w, h)

    // Reset data
    rawStrokes = []
    curRawSampledStroke = []
    curFilteredStroke = []
    pointCounter = 0
    bezierDrawer.reset()
  }

  // ------------------------------------------
  // beginStroke
  //
  // Begins a new stroke containing the given
  // point x, y and p (pressure ranging from
  // 0-1) values.
  //
  beginStroke (x, y, p) {
    var point = new Point(x, y, p)
    pointCounter++

    rawStrokes.push([point])
    curFilteredStroke = [point]
    curRawSampledStroke = [point]

    bezierDrawer.reset()
  }

  // ------------------------------------------
  // extendStroke
  //
  // Extends the current stroke with the given
  // point and renders the new stroke segment
  // to the canvas.
  //
  extendStroke (x, y, p) {
    pointCounter++

    var point = new Point(x, y, p)

    // Raw
    last(rawStrokes).push(point)

    // Sampled and filtered
    if (pointCounter % sample === 0) {
      curRawSampledStroke.push(point)
      // Filter next-to-last input point
      var len = curRawSampledStroke.length
      if (len >= 3) {
        var fpoint = calculateFilteredPoint(
          curRawSampledStroke[len - 3],
          curRawSampledStroke[len - 2],
          curRawSampledStroke[len - 1],
          filterWeight
        )
        curFilteredStroke.push(fpoint)
      }
      // Redraw sampled and filtered
      redraw()
    }
  }

  // ------------------------------------------
  // endStroke
  //
  // Ends the current stroke with the given
  // point and renders the final stroke segment
  // to the canvas.
  //
  endStroke (x, y, p) {
    var point = new Point(x, y, p)
    last(rawStrokes).push(point)
    curRawSampledStroke.push(point)
    curFilteredStroke.push(point)
    redraw()
  }

  // ------------------------------------------
  // getStrokes
  //
  // Returns an array of all strokes that have
  // been recorded, each stroke itself is an
  // array of point JSON objects.
  //
  // [
  //   [{x, y, p}, {x, y, p}, ...],
  //   [{x, y, p}, {x, y, p}, ...],
  //   ...
  // ]
  //
  getStrokes () {
    var strokes = []
    for (var i = 0; i < rawStrokes.length; i++) {
      var stroke = []
      strokes.push(stroke)
      for (var j = 0; j < rawStrokes[i].length; j++) {
        stroke.push(rawStrokes[i][j].asObj())
      }
    }
    return strokes
  }

  // ------------------------------------------
  // setStrokes
  //
  // Sets the strokes to the input array,
  // expected as:
  //
  // [
  //   [{x, y, p}, {x, y, p}, ...],
  //   [{x, y, p}, {x, y, p}, ...],
  //   ...
  // ]
  //
  setStrokes (strokes) {
    // Clear and set rendering to false
    this.clear()
    // applyRendering = !applyRendering;

    // Redraw all the strokes
    for (var i = 0; i < strokes.length; i++) {
      var stroke = strokes[i]
      this.beginStroke(
        stroke[0].x,
        stroke[0].y,
        stroke[0].p
      )
      for (var j = 1; j < stroke.length - 1; j++) {
        this.extendStroke(
          stroke[j].x,
          stroke[j].y,
          stroke[j].p
        )
      }
      this.endStroke(
        stroke[stroke.length - 1].x,
        stroke[stroke.length - 1].y,
        stroke[stroke.length - 1].p
      )
    }
  }

  // ------------------------------------------
  // setSample
  //
  // Sets the input sampling rate.
  //
  setSample (n) {
    sample = n
  }

  // ------------------------------------------
  // resize
  //
  // Resize the Ploma instance to a new width
  // and height.
  //
  resize (a, b) {
    canvas.setAttribute('width', a)
    canvas.setAttribute('height', b)
    w = canvas.getAttribute('width')
    h = canvas.getAttribute('height')
    let oldStrokes = cloneDeep(rawStrokes)
    this.clear()
    this.drawStrokes(oldStrokes)
  }

  drawStrokes (strokes) {
    forEach(strokes, (stroke) => {
      this.drawStroke(stroke)
    })
  }

  drawStroke (points) {
    if (points.length >= 3) {
      let firstPoint = first(points)
      this.beginStroke(firstPoint.x, firstPoint.y, firstPoint.p)
      forEach(tail(initial(points)), (point) => {
        this.extendStroke(point.x, point.y, point.p)
      })
      let lastPoint = last(points)
      this.endStroke(lastPoint.x, lastPoint.y, lastPoint.p)
    }
  }
}

// ------------------------------------------
// redraw
//
// Calls the curve drawing function if there
// are enough points for a bezier.
//
function redraw () {
  var len = curFilteredStroke.length
  if (len >= 3) {
    bezierDrawer.drawControlPoints(
      curFilteredStroke[len - 3],
      curFilteredStroke[len - 2],
      curFilteredStroke[len - 1]
    )
  }
}

// ------------------------------------------
// calculateFilteredPoint
//
// Returns a filtered, sanitized version of
// point p2 between points p1 and p3.
//
function calculateFilteredPoint (p1, p2, p3, filterWeight) {
  var m = p1.getMidPt(p3)
  return new Point(
    filterWeight * p2.x + (1 - filterWeight) * m.x,
    filterWeight * p2.y + (1 - filterWeight) * m.y,
    filterWeight * p2.p + (1 - filterWeight) * m.p
  )
}
