/* eslint camelcase: "off" */
import Point from './Point'
import last from 'lodash/last'

let canvas
let ctx
let lastControlPoint
let imageData
let w
let h
let stepOffset
let stepInterval
let penR, penG, penB

export default class BezierDrawer {

  constructor (passedCanvas, passedInkTextureBase, passedPenColor, passedStepInterval) {
    canvas = passedCanvas
    ctx = canvas.getContext('2d')
    penR = passedPenColor.r
    penG = passedPenColor.g
    penB = passedPenColor.b
    stepInterval = passedStepInterval
    this.reset()
  }

  reset () {
    lastControlPoint = null
    imageData = null
    w = null
    h = null
    stepOffset = stepInterval
  }

  drawControlPoints (pt0, pt1, pt2) {
    cacheVariables()
    createAndDrawBezier(pt0, pt1, pt2)
  }

}

function cacheVariables () {
  w = w || canvas.getAttribute('width')
  h = h || canvas.getAttribute('height')
  imageData = imageData || ctx.getImageData(0, 0, w, h)
}

// ------------------------------------------
// createAndDrawBezier
//
// Draw a look-ahead cubic bezier based on 3
// input points.
//
function createAndDrawBezier (pt0, pt1, pt2) {
  // Endpoints and control points
  let p0 = pt0
  let p1 = 0.0
  let p2 = 0.0
  let p3 = pt1

  // Value access
  let p0_x = p0.x
  let p0_y = p0.y
  let p0_p = p0.p
  let p3_x = p3.x
  let p3_y = p3.y
  let p3_p = p3.p

  // Calculate p1
  if (!lastControlPoint) {
    p1 = new Point(
      p0_x + (p3_x - p0_x) * 0.33,
      p0_y + (p3_y - p0_y) * 0.33,
      p0_p + (p3_p - p0_p) * 0.33
    )
  } else {
    p1 = lastControlPoint.getMirroredPt(p0)
  }

  // Calculate p2
  if (pt2) {
    p2 = new Point(
      p3_x - (((p3_x - p0_x) + (pt2.x - p3_x)) * 0.1666),
      p3_y - (((p3_y - p0_y) + (pt2.y - p3_y)) * 0.1666),
      p3_p - (((p3_p - p0_p) + (pt2.p - p3_p)) * 0.1666)
    )
  } else {
    p2 = new Point(
      p0_x + (p3_x - p0_x) * 0.66,
      p0_y + (p3_y - p0_y) * 0.66,
      p0_p + (p3_p - p0_p) * 0.66
    )
  }

  // Set last control point
  lastControlPoint = p2

  // Step along curve and draw step
  let stepPoints = calculateStepPoints(p0, p1, p2, p3)
  for (let i = 0; i < stepPoints.length; i++) {
    drawStep(imageData.data, stepPoints[i])
  }

  // Calculate redraw bounds
  // TODO:
  // - Math.min = x <= y ? x : y; INLINE
  let p1_x = p1.x
  let p1_y = p1.y
  let p2_x = p2.x
  let p2_y = p2.y
  let minx = Math.min(p0_x, p1_x, p2_x, p3_x)
  let miny = Math.min(p0_y, p1_y, p2_y, p3_y)
  let maxx = Math.max(p0_x, p1_x, p2_x, p3_x)
  let maxy = Math.max(p0_y, p1_y, p2_y, p3_y)

  // Put image using a crude dirty rect
  // elapsed = Date.now() - elapsed;
  // console.log(elapsed);
  ctx.putImageData(
    imageData,
    0,
    0,
    minx - 5,
    miny - 5,
    (maxx - minx) + 10,
    (maxy - miny) + 10
  )
}

// ------------------------------------------
// calculateStepPoints
//
// Calculates even steps along a bezier with
// control points (p0, p1, p2, p3).
//
function calculateStepPoints (p0, p1, p2, p3) {
  let stepPoints = []
  let i = stepInterval

  // Value access
  let p0_x = p0.x
  let p0_y = p0.y
  let p0_p = p0.p

  // Algebraic conveniences, not geometric
  let A_x = p3.x - 3 * p2.x + 3 * p1.x - p0_x
  let A_y = p3.y - 3 * p2.y + 3 * p1.y - p0_y
  let A_p = p3.p - 3 * p2.p + 3 * p1.p - p0_p
  let B_x = 3 * p2.x - 6 * p1.x + 3 * p0_x
  let B_y = 3 * p2.y - 6 * p1.y + 3 * p0_y
  let B_p = 3 * p2.p - 6 * p1.p + 3 * p0_p
  let C_x = 3 * p1.x - 3 * p0_x
  let C_y = 3 * p1.y - 3 * p0_y
  let C_p = 3 * p1.p - 3 * p0_p

  let t = (i - stepOffset) / Math.sqrt(C_x * C_x + C_y * C_y)

  while (t <= 1.0) {
    // Point
    let step_x = t * (t * (t * A_x + B_x) + C_x) + p0_x
    let step_y = t * (t * (t * A_y + B_y) + C_y) + p0_y
    let step_p = t * (t * (t * A_p + B_p) + C_p) + p0_p
    stepPoints.push(new Point(
      step_x,
      step_y,
      step_p
    ))

    // Step distance until next one
    let s_x = t * (t * 3 * A_x + 2 * B_x) + C_x // dx/dt
    let s_y = t * (t * 3 * A_y + 2 * B_y) + C_y // dy/dt
    let s = Math.sqrt(s_x * s_x + s_y * s_y) // s = derivative in 2D space
    let dt = i / s // i = interval / derivative in 2D
    t = t + dt
  }

  // TODO: Maybe use a better approximation for distance along the bezier?
  if (stepPoints.length === 0) {
    // We didn't step at all along this Bezier
    stepOffset = stepOffset + p0.getDistance(p3)
  } else {
    stepOffset = last(stepPoints).getDistance(p3)
  }
  return stepPoints
}

// ------------------------------------------
// calculateWidth
//
// Calculates a non-linear width offset in
// the range [-2, 1] based on pressure.
//
function calculateWidth (p) {
  let width = 0.0
  // console.log(p);

  if (p < 0) { // Possible output from bezier
    width = -3.50
  }
  if (p < 0.2) {
    width = map(p, 0, 0.2, -3.50, -3.20)
  }
  if ((p >= 0.2) && (p < 0.45)) {
    width = map(p, 0.2, 0.45, -3.20, -2.50)
  }
  if ((p >= 0.45) && (p < 0.8)) {
    width = map(p, 0.45, 0.8, -2.50, -1.70)
  }
  if ((p >= 0.8) && (p < 0.95)) {
    width = map(p, 0.8, 0.95, -1.70, -1.55)
  }
  if ((p >= 0.95) && (p <= 1)) {
    width = map(p, 0.95, 1, -1.55, -1.30)
  }
  if (p > 1) { // Possible output from bezier
    width = -1.30
  }

  return width
}

function map (value, valueMin, valueMax, from, to) {
  let ratio = (value - valueMin) / (valueMax - valueMin)
  return from + ratio * (to - from)
}

// ------------------------------------------
// drawStep
//
// Draws a 5x5 pixel grid at a step point
// with proper antialiasing.
//
function drawStep (imageDataData, point) {
  // PRE-LOOP
  let width = 0.0
  width = calculateWidth(point.p)

  // LOOP
  let p_x = 0.0
  let p_y = 0.0
  let centerX = 0.0
  let centerY = 0.0
  let i = 0
  let j = 0
  let left = 0
  let right = 0
  let top = 0
  let bottom = 0
  let dx = 0.0
  let dy = 0.0
  let dist = 0.0
  let a = 0.0
  let invA = 0.0
  let idx_0 = 0
  let idx_1 = 0
  let idx_2 = 0
  let idx_0_i = 0
  let oldR = 0.0
  let oldG = 0.0
  let oldB = 0.0
  let newR = 0.0
  let newG = 0.0
  let newB = 0.0

  p_x = point.x
  p_y = point.y
  centerX = Math.round(p_x)
  centerY = Math.round(p_y)
  left = centerX - 2
  right = centerX + 3
  top = centerY - 2
  bottom = centerY + 3

  // Horizontal
  for (i = left; i < right; i++) {
    // Distance
    dx = p_x - i

    // Byte-index
    idx_0_i = i * 4

    // Vertical
    for (j = top; j < bottom; j++) {
      // Distance
      dy = p_y - j
      dist = Math.sqrt(dx * dx + dy * dy)

      // Byte-index
      idx_0 = idx_0_i + j * (w * 4)

      // Antialiasing
      // a = 5 * ((0.3 / (dist - width)) - 0.085)
      a = (1.5 / (dist - width)) - 0.425

      // Spike
      if (dist < width) {
        a = 1
      }

      // Clamp alpha
      if (a < 0) a = 0
      if (a >= 1) a = 1

      // Blending lets
      invA = 1 - a
      idx_1 = idx_0 + 1
      idx_2 = idx_0 + 2
      oldR = imageDataData[idx_0]
      oldG = imageDataData[idx_1]
      oldB = imageDataData[idx_2]

      newR = penR * a + oldR * invA
      newG = penG * a + oldG * invA
      newB = penB * a + oldB * invA

      // Set new RGB
      imageDataData[idx_0] = newR
      imageDataData[idx_1] = newG
      imageDataData[idx_2] = newB
    }
  }
}
