{\rtf1\ansi\ansicpg1252\cocoartf1404\cocoasubrtf470
{\fonttbl\f0\fnil\fcharset0 Hack-Regular;\f1\fnil\fcharset0 Hack-Bold;}
{\colortbl;\red255\green255\blue255;}
\margl1440\margr1440\vieww16280\viewh14020\viewkind0
\deftab720
\pard\pardeftab720\pardirnatural\partightenfactor0

\f0\fs28 \cf0 CreateWindow(width, height)\
\{\
\pard\pardeftab720\li360\pardirnatural\partightenfactor0
\cf0 // Create and initialize a display window\
\
// Allocate and clear a vector distance map associated with the \
// display window for sampling and storing the vector distance field \
// of a polyline connecting a sequence of digitized mouse points\
vectorDistMap 
\f1\b \uc0\u8592 
\f0\b0  CreateVectorDistMap(width, height);\
\pard\pardeftab720\pardirnatural\partightenfactor0
\cf0 \}\
\
DestroyWindow(window)\
\{\
\pard\pardeftab720\li360\pardirnatural\partightenfactor0
\cf0 // Free the vector distance map associated with the display window\
Free(vectorDistMap);\
\
// Destroy the display window\
\pard\pardeftab720\pardirnatural\partightenfactor0
\cf0 \}\
\
MouseDownCallback(x, y)\
\{\
\pard\pardeftab720\li360\pardirnatural\partightenfactor0
\cf0 // Initialize a piecewise parametric curve\
curve 
\f1\b \uc0\u8592 
\f0\b0  InitParametricCurve()\
\
// Initialize the first curve segment in the piecewise parametric\
// curve\
InitCurveSegment(x, y, curve.curveSeg[0])\
\pard\pardeftab720\li1080\pardirnatural\partightenfactor0
\cf0 \
\pard\pardeftab720\li360\pardirnatural\partightenfactor0
\cf0 // Clear the vector distance map\
ClearVectorDistMap(vectorDistMap);\
\pard\pardeftab720\pardirnatural\partightenfactor0
\cf0 \}\
\
MouseUpCallback()\
\{\
\pard\pardeftab720\li360\pardirnatural\partightenfactor0
\cf0 // Terminate the parametric curve\
TermParametricCurve(curve)\
\pard\pardeftab720\pardirnatural\partightenfactor0
\cf0 \}\
\
MouseMoveCallback(x, y)\
\{\
\pard\pardeftab720\li360\pardirnatural\partightenfactor0
\cf0 // Attempt to update the current curve segment with the new \
// digitized point (x, y)\
updateResult 
\f1\b \uc0\u8592 
\f0\b0  UpdateCurveSegment(x, y, currentSeg)\
\
// Start a new curve if the current curve segment was not updated\
// successfully\
if (updateResult != SUCCESS) \{\
\
\pard\pardeftab720\li720\pardirnatural\partightenfactor0
\cf0 // Terminate the previous curve segment at its previous endpoint\
// (xPrev, yPrev)\
TermCurveSegment(currentSeg)\
\
\pard\pardeftab720\li360\pardirnatural\partightenfactor0
\cf0 	// Clear the vector distance map\
	ClearVectorDistMap(vectorDistMap);\
\pard\pardeftab720\li720\pardirnatural\partightenfactor0
\cf0 \
// Initialize a new curve segment beginning at (xPrev, yPrev) \
\pard\pardeftab720\li360\pardirnatural\partightenfactor0
\cf0 	InitCurveSegment(xPrev, yPrev, nextSeg)\
\pard\pardeftab720\li720\pardirnatural\partightenfactor0
\cf0 \
// Constrain the tangent vector at the first endpoint of the new\
// curve segment to be parallel to the tangent vector at the end\
// of the current curve segment in order to maintain G1 \
// continuity unless a corner was detected\
\pard\pardeftab720\li360\pardirnatural\partightenfactor0
\cf0 	if (updateResult == FAILURE) nextSeg.constrained 
\f1\b \uc0\u8592 
\f0\b0  TRUE\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4425\pardeftab720\li360\pardirnatural\partightenfactor0
\cf0 	else if (updateResult == CORNER) nextSeg.constrained 
\f1\b \uc0\u8592 
\f0\b0  FALSE\
\pard\pardeftab720\li360\pardirnatural\partightenfactor0
\cf0 \
	// Update the new curve segment to include (x, y) and reset the\
	// current curve segment to be the new curve segment\
	UpdateCurveSegment(x, y, nextSeg)\
	currentSeg 
\f1\b \uc0\u8592 
\f0\b0  nextSeg\
\}	\
\pard\pardeftab720\pardirnatural\partightenfactor0
\cf0 \}\
\
InitCurveSegment(x, y, curveSegment)\
\{\
\pard\pardeftab720\li360\pardirnatural\partightenfactor0
\cf0 // Initialize the curve segment\'92s 4 control vertices to (x, y)\
curveSegment.C0 
\f1\b \uc0\u8592 
\f0\b0  (x, y)\
curveSegment.C1 
\f1\b \uc0\u8592 
\f0\b0  (x, y)\
curveSegment.C2 
\f1\b \uc0\u8592 
\f0\b0  (x, y)\
curveSegment.C3 
\f1\b \uc0\u8592 
\f0\b0  (x, y)\
\pard\pardeftab720\pardirnatural\partightenfactor0
\cf0 \}\
\
UpdateCurveSegment(x, y, curveSegment)\
\{\
\pard\pardeftab720\li360\pardirnatural\partightenfactor0
\cf0 // Test for a corner between (x, y) and (xPrev, yPrev). A corner is\
// detected at (xPrev, yPrev) if the angle between the tangent at \
// the end of the curve segment and the new line segment is greater \
// than a minimum corner angle (e.g., 60 degrees).\
if (TestCorner(x, y, curveSegment) return(CORNER)\
\
// Reset the positions of the 3\super rd\nosupersub  and 4\super th\nosupersub  control vertices. Move the\
// 4\super th\nosupersub  control vertex from its previous position (xPrev, yPrev) to \
// (x, y) and move the 3\super rd\nosupersub  control vertex by the same amount (i.e., \
// by (x \'96 xPrev, y \'96 yPrev))\
(xPrev, yPrev) 
\f1\b \uc0\u8592 
\f0\b0  curveSegment.C3\sub \
\nosupersub curveSegment.C3 
\f1\b \uc0\u8592 
\f0\b0  
\f1\b (
\f0\b0 x, y)\
curveSegment.C2 
\f1\b \uc0\u8592 
\f0\b0  curveSegment.C2 + (x, y) - (xPrev, yPrev)\
\
// Update the vector distance map, adding contributions from the new\
// line segment (i.e., the line segment from (xPrev, yPrev) to \
// (x, y)) and the point (xPrev, yPrev). The fieldRadius limits the \
// range from the line segment or point where the vector distance \
// field is computed. The fieldRadius should be as small as possible \
// to limit the number of distance computations required but large \
// enough so that the estimating curve almost always lies within \
// this range of the polyline. \
RenderLineCell(xPrev, yPrev, x, y, fieldRadius, vectorDistMap)\
RenderPointCell(xPrev, yPrev, fieldRadius, vectorDistMap)\
\pard\pardeftab720\li1800\pardirnatural\partightenfactor0
\cf0 \
\pard\pardeftab720\li360\pardirnatural\partightenfactor0
\cf0 // Adjust the positions of the off-curve control vertices, C1 and\
// C2. Iterate until the curve error is below threshold or a maximum\
// number of iterations has been performed\
while ((error > maxError) AND (nIteration < maxNIteration) \{\
\
   // Determine the force vectors f\sub 1\nosupersub  and f\sub 2 \nosupersub acting on off-curve\
   // control vertices C1 and C2,\sub  \nosupersub respectively. Initialize both \
   // forces to the zero vector and then add force contributions \
   // from each sample point B(t\sub i\nosupersub ) along the cubic Bezier curve \
   // segment, where t\sub i\nosupersub  = i / N, i = 1, 2, \'85 N, and N is the number \
   // of sample points.\
   f\sub 1\nosupersub  
\f1\b \uc0\u8592 
\f0\b0  (0, 0)\
   f\sub 2\nosupersub  
\f1\b \uc0\u8592 
\f0\b0  (0, 0)\
   for (i = 0, i < N, i++) \{\
 \
      // Compute the vector distance (dx, dy) and the Euclidean \
      // distance, d = sqrt(dx\super 2\nosupersub  + dy\super 2\nosupersub ), from the polyline at the \
      // sample point by interpolating the vector distance map\
      (x, y) 
\f1\b \uc0\u8592 
\f0\b0  B(t\sub i\nosupersub )\
      (dx, dy) 
\f1\b \uc0\u8592 
\f0\b0  InterpVectorDist(vectorDistMap, x, y)\
      d 
\f1\b \uc0\u8592 
\f0\b0  sqrt(dx\super 2\nosupersub  + dy\super 2\nosupersub )\
\
      // Determine the force contributions to each force vector at\
      // this sample point and add them to f\sub 1\nosupersub  and f\sub 2\nosupersub \
      f\sub 1\nosupersub (t\sub i\nosupersub ) 
\f1\b \uc0\u8592 
\f0\b0  6 * t\sub i\nosupersub  * (1 \'96 t\sub i\nosupersub )\super 2 \nosupersub * d * (dx, dy)\
      f\sub 2\nosupersub (t\sub i\nosupersub ) 
\f1\b \uc0\u8592 
\f0\b0  6 * t\sub i\super 2\nosupersub  * (1 \'96 t\sub i\nosupersub )\super  \nosupersub * d * (dx, dy)\
   \}\
\pard\pardeftab720\li3240\pardirnatural\partightenfactor0
\cf0 \
\pard\pardeftab720\li360\pardirnatural\partightenfactor0
\cf0    // Constrain f\sub 1\nosupersub  to be parallel to (xTan, yTan) if the tangent at\
   // the first endpoint is constrained\
   if (curveSegment.constrained == TRUE) \{\
      f\sub 1\nosupersub (t\sub i\nosupersub ) 
\f1\b \uc0\u8592 
\f0\b0  dotProduct((xTan, yTan), f\sub 1\nosupersub (t\sub i\nosupersub )) * (xTan, yTan)\
   \}\
\
   // Move each of the off curve control vertices using the\
   // force vectors\
   curveSegment.C1 
\f1\b \uc0\u8592 
\f0\b0  curveSegment.C1 + f\sub 1\nosupersub \
   curveSegment.C2 
\f1\b \uc0\u8592 
\f0\b0  curveSegment.C2 + f\sub 2\nosupersub \
\
   // Compute the curve error, i.e., the sum of the squared \
   // Euclidean distances from sample points along the curve to the\
   // polyline. Initialize the error to zero and then add the\
   // contribution to the error from each sample point B(t\sub i\nosupersub ) along\
   // the cubic Bezier curve segment, where t\sub i\nosupersub  = i / N, i = 1, \'85 N, \
   // and N is the number of sample points\
   error 
\f1\b \uc0\u8592 
\f0\b0  0\
   for (i = 0, i < N, i++) \{\
      (x, y) 
\f1\b \uc0\u8592 
\f0\b0  B(t\sub i\nosupersub )\
      (dx, dy) 
\f1\b \uc0\u8592 
\f0\b0  InterpVectorDist(vectorDistMap, x, y)\
      error 
\f1\b \uc0\u8592 
\f0\b0  error + dx\super 2\nosupersub  + dy\super 2\nosupersub \
   \}\
\
   // Test for a successful curve fitting\
   if (error < maxError) return(SUCCESS) \
\}\
\
// The curve fitting failed. Reset the curve\'92s control vertices to\
// their original values and return FAILURE.\
ResetControlVertices(curveSegment)\
return(FAILURE)\
\pard\pardeftab720\pardirnatural\partightenfactor0
\cf0 \}\
\pard\pardeftab720\li360\pardirnatural\partightenfactor0
\cf0 \
\
\pard\pardeftab720\pardirnatural\partightenfactor0
\cf0 RenderLineCell(x\sub 0\nosupersub , y\sub 0\nosupersub , x\sub 1\nosupersub , y\sub 1\nosupersub , fieldRadius, vectorDistMap)\
\{\
\pard\pardeftab720\li360\pardirnatural\partightenfactor0
\cf0 // Determine the edges of a rectangular line cell centered on the\
// line segment from (x\sub 0\nosupersub , y\sub 0\nosupersub ) to (x\sub 1\nosupersub , y\sub 1\nosupersub ) with width twice\
// fieldRadius\
\
// Determine the vector distance at the bottom-left vertex of the\
// line cell (i.e., the vector distance from the vertex to the line\
// line segment)\
\
// Determine the change in the vector distance with unit changes in\
// x and y\
\
// Rasterize the line cell (e.g., using an active edge list \
// algorithm), making use of the fact that the x and y components of\
// the vector distance are linear inside the line cell and can be \
// computed incrementally using a digital differential analyzer \
// (see [4])\
\pard\pardeftab720\pardirnatural\partightenfactor0
\cf0 \}\
\
RenderPointCell(x, y, fieldRadius, vectorDistMap)\
\{\
\pard\pardeftab720\li360\pardirnatural\partightenfactor0
\cf0 // Determine the edges of a square, axis-aligned point cell centered\
//  on (x, y) with side lengths twice fieldRadius (see Figure 2)\
\
// Determine the vector distance at the bottom-left vertex of the \
// line cell (i.e., the vector distance from the vertex to (x, y)\
\
// Determine the change in the vector distance with unit changes in\
// x and y\
\
// Rasterize the point cell using a digital differential analyzer\
\pard\pardeftab720\pardirnatural\partightenfactor0
\cf0 \}\
}